Это – микро-фреймворк для стресс-тестирования (и обычного тестирования тоже) решений, в основном, для алгосов.

# Файловая структура

```
Template/
├── code/
│   ├── <main.cpp, main.py>
│   ├── <gen.cpp, main.py>
│   └── <sol.cpp, sol.py>
├── exec/
│   ├── main.e
│   ├── gen.e
│   └── sol.e
├── scripts/
│   ├── .comp
│   ├── cc
│   ├── ic
│   ├── rc
│   ├── ro
│   └── rrc
├── test_o/
│   ├── 1/
│   │   ├── in
│   │   ├── out
│   │   └── ans
│   ...
└── test_c/
    ├── in
    ├── out
    └── ans
```

# Описание структуры
Итак, зачем же для одной задачи по алгосам иметь пять папок и больше 18 файлов?
### `/code`
Здесь находится весь твой код (поддерживаемые языки: C++, Python 3):
- в `<main.cpp, main.py>` – твоё решение
- `<gen.cpp, gen.py>` предназначен для генератора тестов, если ты хочешь погенерить свои тесты
- `<sol.cpp, sol.py>` – твоё тупое, но точно работающее решение (или не твоё :D) или же `std::solve();`. Пригодится для стресс-тестов. Можно оставить с пустым `int main() {}`

Если в папке есть `<main,gen,sol>.cpp`, то соответвующий файл `.py` при его существовании будет игнорироваться

### `/exec`
Здесь лежат скомпилированные коды из `/code`. Тебе сюда незачем заглядывать

### `/test_o` и `/test_c`
Две папки для всех вводов и выводов (но без аксиом вывода T~T). Главное различие между ними: `/test_o` – "test_original" – предназначена для тестов из условия, а `/test_c` – "test_custom" – для стресс тестирования. В `/test_o` лежат несколько папок с тестами, назвынные числами. `/test_c` сама является тестом. Каждый тест (`/test_o/<num>` и `/test_c`) содержит в себе:
- `in` – ввод, который будет подаваться решениям
- В `out` будет лежать ответ, данный `exec/main.e`. Туда попадает как stdout, так и stderr, поэтому если ты не уважал личные границы `std::vector`, там ты найдёшь и сообщение санитайзера. Однако все проверяющие скрипты игнорируют всё, что идёт после "!" (включая "!"), что позволяет использовать `std::cerr << '!' << ...;`, не нарушая работу проверяющих скриптов. Если же вдруг "!" оказался частью нужного вывода, ты можешь заменить этот спец.символ на удобный тебе в файле `/scripts/.comp`
- `ans` предназначен для предпосчитанного ответа в случае `/test_o` и ответа `sol.<cpp,py>` в случае `/test_c`

HINT: Можно использовать `/test_o` и для своих придуманных тестов

### `/scripts`
Самое интересное; то, зачем весь этот фреймворк и сделан. Каждый файл здесь – скрипт, запускающий один из сценариев тестирования

!!! ВАЖНО: ожидается, что скрипты будут запускаться из этой папки, поэтому перед работой пропиши `cd scripts`

Итак, вот каждый из скриптов:
- `./.comp` – внутренний скрипт, используемый для сравнивания выводов. Ты можешь в нём поменять символ, обозначающий начало "игнорируемого ввода"
- `./ro` – "run_original": Компилирует код и запускает все тесты из `/test_o`. Скажет, совпадает ли ответ программы с ответом из `test_o/<num>/ans`. Или просто скажет, что ты ленивый, если `test_o/<num>/ans` пуст, поэтому ты можешь оставить его пустым, если необходимо проверить лишь работоспособность решения
- `./сс` – "compile_custom": Только компилирует все коды из `/code`. Это нужно, чтобы при запуске остальных стресс-тестов не компилировать все программы. Поэтому после того, как ты изменил свой код, напиши `./cc` перед тем, как запускать остальные скрипты, оканчивающиеся на 'c'.
- `./rc` – "run_custom": запускает сначала `exec/gen.e`, чтобы сгенерить тест в `test_c/in`, затем `exec/sol.e`, чтобы записать ответ в `test_c/ans`, затем запускает `exec/main.e` и сверяет ответ (или назовёт тебя ленивым, если `exec/sol.e` ничего не делает). Также считает время выполнения каждого шага
- `./rrc` – "rerun_custom": то же саоме, что и `./rc`, но не генерирует новый тест, а использует старый. HINT: моя стратегия – спамить `./rc`, пока что-нибудь не ляжет, затем фиксить, проверяя уже через `./rrc` на том же тесте, на котором всё ложилось
- `./ic` – "iterate_custom": проведёт 1000 итераций, аналогичных `./rc` и остановится, как только найдёт несходство. Если `exec/sol.e` ничего не делает или отсутствует, проверит программу на предмет RE. Не считает время выполнения

## Мои рекомендации для использования в VScode
В основном окне открыты `code/main.<cpp,py>`, а также `code/gen.<cpp,py>` и `code/sol.<cpp,py>`. Снизу – консоль для вызова скриптов (можно открыть, написав в верхней поисковой строке ">create new terminal"). Справа в два ряда открыты тесты: в верхней части `test_o/<num>/in` и `test_c/in`, в нижней – `test_o/<num>out` и `test_c/out`. Если на экране хватает места – можно рассплитить часть c `in`'ами и в правой открыть `test_o/<num>/ans`

[[ TODO: прикрепить скриншот ]]

# Post-scriptum

Сейчас в `/code` нерабочее решение простой задачки. Попробуй отдебажить его, используя скрипты

[[ TODO: сделать скрипт, создающий папку со всеми скриптами ]]

[[ сложный TODO: сделать это всё утилитой]]

by: Захаров Марк, МФТИ ФПМИ (Telegram: @Im_Not_GLaDOS)