Это – микро-фреймворк для стресс-тестирования (и обычного тестирования тоже) решений, в основном, для алгосов.

# Файловая структура
Итак, зачем же для одной задачи по алгосам иметь пять папок и 17 файлов?
### `/code`
Здесь находится весь твой код:
- в `main.cpp` – твоё решение
- `gen.cpp` предназначен для генератора тестов, если ты хочешь погенерить свои тесты
- `sol.cpp` – твоё тупое, но точно работающее решение (или не твоё :D) или же `std::solve();`. Пригодится для стресс-тестов. Можно оставить с пустым `int main() {}`

[[ TODO: поддержка python-based генератора и солвера ]]

### `/exec`
Здесь лежат скомпилированные коды из `/code`. Тебе сюда незачем заглядывать

### `/test_o` и `/test_c`
Две папки для всех вводов и выводов (но без аксиом вывода T~T). Различие между ними одно: `/test_o` – "test_original" – предназначена для тестов из условия, а `/test_c` – "test_custom" – для стресс тестирования. У обоих одинаковая структура:
- `in` – ввод, который будет подаваться решениям
- В `out` будет лежать ответ, данный `exec/main.e`. Пока что туда попадает как stdout, так и stderr, поэтому если ты не уважал личные границы `std::vector`, там ты найдёшь и сообщение санитайзера
- `ans` предназначен для предпосчитанного ответа в случае `/test_o` и ответа `sol.cpp` в случае `/test_c`

HINT: Можно использовать `/test_o` и для своих тестов вместо тестов из условия. 

[[ TODO: поддержка нескольких тестов в `test_o` ]]

[[ TODO: разделение stdout и stderr ]]

### `/scripts`
Самое интересное; то, зачем весь этот фреймворк и сделан. Каждый файл здесь – скрипт, запускающий один из сценариев тестирования

!!! ВАЖНО: ожидается, что скрипты будут запускаться из этой папки, поэтому перед работой пропиши `cd scripts`

Итак, вот каждый из скриптов:
- `./ro` – "run_original": Компилирует и запускает тест из `/test_o`. Скажет, совпадает ли ответ программы с ответом из `test_o/ans`. Или просто скажет, что ты ленивый, если `test_o/ans` пуст, поэтому его не обязательно заполнять
- `./сс` – "compile_custom": Только компилирует все коды из `/code`. Это нужно, чтобы при запуске остальных стресс-тестов не компилировать все программы. Поэтому после того, как ты изменил свой код, напиши `./cc` перед тем: как запускать остальные скрипты, оканчивающиеся на 'c'.
- `./rc` – "run_custom": запускает сначала `exec/gen.e`, чтобы сгенерить тест в `test_c/in`, затем `exec/sol.e`, чтобы записать ответ в `test_c/ans`, затем запускает `exec/main.e` и сверяет ответ (или назовёт тебя ленивым, если `exec/sol.e` ничего не делает). Также считает время выполнения каждого шага
- `./rrc` – "rerun_custom": то же саоме, что и `./rc`, но не генерирует новый тест, а использует старый. HINT: моя стратегия – спамить `./rc`, пока что-нибудь не ляжет, затем фиксить, проверяя уже через `./rrc` на том же тесте, на котором всё ложилось
- `./ic` – "iterate_custom": проведёт 1000 итераций, аналогичных `./rc` и остановится, как только найдёт несходство. Если `exec/sol.e` ничего не делает, проверит программу на предмет RE. Не считает время выполнения

## Мои рекомендации для использования в VScode
В основном окне открыты `code/main.cpp`, а также `code/gen.cpp` и `code/sol.cpp`. Снизу – консоль для вызова скриптов (можно открыть, написав в верхней поисковой строке ">create new terminal"). Справа в два ряда открыты тесты: в верхней части `test_o/in` и `test_c/in`, в нижней – `test_o/out` и `test_c/out`. Если на экране хватает места – можно рассплитить часть c `in`'ами и в правой открыть `test_o/ans`

[[ TODO: прикрепить скриншот ]]

# Post-scriptum

Сейчас в `/code` нерабочее решение простой задачки. Попробуй отдебажить его, используя скрипты

[[ TODO: сделать скрипт, создающий папку со всеми скриптами ]]

[[ сложный TODO: сделать это всё утилитой]]

by: Захаров Марк, МФТИ ФПМИ

Контакты для предложений, обратной связи, bug-репортов, благодарностей, ~~проклятий~~:
- тг: @Im_Not_GLaDOS
- тг анон-бот: https://t.me/anoquebot?start=yrvmv8gp